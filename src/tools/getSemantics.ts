import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { Ok } from 'ts-results-es';
import { z } from 'zod';

import { getConfig } from '../config.js';
import { useRestApi } from '../restApiInstance.js';
import { Server } from '../server.js';
import { Tool } from './tool.js';
import { validateDatasourceLuid } from './validateDatasourceLuid.js';

// Query 1: Get ONLY published data source fields (no workbook data)
export const getPublishedDataSourceQuery = (datasourceLuid: string): string => `
  query publishedDatasourceFieldsOnly {
    publishedDatasources(filter: { luid: "${datasourceLuid}" }) {
      name
      description
      owner {
        name
      }
      fields {
        name
        isHidden
        description
        descriptionInherited {
          attribute
          value
        }
        fullyQualifiedName
        __typename
        ... on AnalyticsField {
          __typename
        }
        ... on ColumnField {
          dataCategory
          role
          dataType
          defaultFormat
          semanticRole
          aggregation
          aggregationParam
        }
        ... on CalculatedField {
          dataCategory
          role
          dataType
          defaultFormat
          semanticRole
          aggregation
          aggregationParam
          formula
          isAutoGenerated
          hasUserReference
        }
        ... on BinField {
          dataCategory
          role
          dataType
          formula
          binSize
        }
        ... on GroupField {
          dataCategory
          role
          dataType
          hasOther
        }
        ... on CombinedSetField {
          delimiter
          combinationType
        }
      }
    }
  }`;

// Query 2: Get workbooks using this data source and their embedded data sources
export const getWorkbookSemanticsQuery = (
    datasourceLuid: string,
    workbookLuid?: string,
): string => `
  query workbookSemantics {
    publishedDatasources(filter: { luid: "${datasourceLuid}" }) {
      downstreamWorkbooks${workbookLuid ? `(filter: { luid: "${workbookLuid}" })` : ''} {
        id
        luid
        name
        projectName
        owner {
          name
        }
        embeddedDatasources {
          id
          name
          fields {
            name
            isHidden
            description
            descriptionInherited {
              attribute
              value
            }
            fullyQualifiedName
            __typename
            ... on AnalyticsField {
              __typename
            }
            ... on ColumnField {
              dataCategory
              role
              dataType
              defaultFormat
              semanticRole
              aggregation
              aggregationParam
            }
            ... on CalculatedField {
              dataCategory
              role
              dataType
              defaultFormat
              semanticRole
              aggregation
              aggregationParam
              formula
              isAutoGenerated
              hasUserReference
            }
            ... on BinField {
              dataCategory
              role
              dataType
              formula
              binSize
            }
            ... on GroupField {
              dataCategory
              role
              dataType
              hasOther
            }
            ... on CombinedSetField {
              delimiter
              combinationType
            }
          }
        }
      }
    }
  }`;

interface Field {
    name: string;
    isHidden: boolean | null;
    description?: string | null;
    descriptionInherited?:
    | ({
        attribute: string;
        value: string | null;
    } | null)[]
    | null;
    fullyQualifiedName: string;
    __typename: string;
    [key: string]: any; // For additional field-specific properties
}

interface WorkbookSemantics {
    workbookName: string;
    workbookLuid: string;
    projectName: string;
    owner: {
        name: string;
    };
    uniqueFields: Field[];
}

/**
 * Processes the GraphQL response to extract unique workbook-level semantics
 * Limits processing to the first workbook to focus on the most relevant ones
 */
function extractWorkbookSemantics(
    publishedFields: Field[],
    downstreamWorkbooks: any[],
): WorkbookSemantics[] {
    // Create multiple sets for different field comparison strategies
    const publishedFieldsByFQN = new Set(publishedFields.map((f) => f.fullyQualifiedName));
    const publishedFieldsByName = new Set(publishedFields.map((f) => f.name));
    const publishedFieldsByFieldCaption = new Set(
        publishedFields.map((f) => (f as any).fieldCaption).filter(Boolean)
    );

    console.log('Published fields debug:');
    console.log('  Count:', publishedFields.length);
    console.log('  Sample FQN:', Array.from(publishedFieldsByFQN).slice(0, 3));
    console.log('  Sample names:', Array.from(publishedFieldsByName).slice(0, 3));
    console.log('  Sample fieldCaptions:', Array.from(publishedFieldsByFieldCaption).slice(0, 3));

    const workbookSemantics: WorkbookSemantics[] = [];

    // Process only the first workbook (since we can't order by view count in GraphQL)
    const workbooksToProcess = downstreamWorkbooks.slice(0, 1);

    for (const workbook of workbooksToProcess) {
        const uniqueFields: Field[] = [];

        // Process all embedded data sources in this workbook
        for (const embeddedDatasource of workbook.embeddedDatasources || []) {
            console.log(`Processing embedded datasource: ${embeddedDatasource.name}`);
            console.log(`  Field count: ${embeddedDatasource.fields?.length || 0}`);

            for (const field of embeddedDatasource.fields || []) {
                // Try multiple comparison strategies to catch field mappings
                const fieldFQN = field.fullyQualifiedName;
                const fieldName = field.name;
                const fieldCaption = (field as any).fieldCaption;

                const isInPublished =
                    publishedFieldsByFQN.has(fieldFQN) ||
                    publishedFieldsByName.has(fieldName) ||
                    (fieldCaption && publishedFieldsByFieldCaption.has(fieldCaption));

                if (!isInPublished) {
                    console.log(`  Found unique field: ${fieldName} (${fieldFQN})`);
                    // This field is unique to the workbook (workbook-level semantic)
                    uniqueFields.push(field);
                } else {
                    console.log(`  Field exists in published: ${fieldName} (${fieldFQN})`);
                }
            }
        }

        console.log(`Total unique fields found for workbook ${workbook.name}: ${uniqueFields.length}`);

        // Always include workbooks in the result, even if they have no unique fields
        // This helps with debugging and provides transparency
        workbookSemantics.push({
            workbookName: workbook.name,
            workbookLuid: workbook.luid,
            projectName: workbook.projectName,
            owner: workbook.owner,
            uniqueFields,
        });
    }
    return workbookSemantics;
}

const paramsSchema = {
    datasourceLuid: z.string().nonempty(),
};

export const getGetSemanticsTool = (server: Server): Tool<typeof paramsSchema> => {
    const getSemanticsTool = new Tool({
        server,
        name: 'get-semantics',
        description: `
    Fetches semantic metadata for a target data source by query the metadata of the published data sources and relevant downstream workbooks. 
    The semantics concepts returned in the workbook semantics object can be used for subsequent data queries, but the field names 
    cannot be referred to explicitly. 
    `,
        paramsSchema,
        annotations: {
            title: 'Get Semantics',
            readOnlyHint: true,
            openWorldHint: false,
        },
        argsValidator: validateDatasourceLuid,
        callback: async ({ datasourceLuid }, { requestId }): Promise<CallToolResult> => {
            const config = getConfig();

            return await getSemanticsTool.logAndExecute({
                requestId,
                args: { datasourceLuid },
                callback: async () => {
                    return new Ok(
                        await useRestApi({
                            config,
                            requestId,
                            server,
                            jwtScopes: ['tableau:content:read'],
                            callback: async (restApi) => {
                                // Use Zodios method directly but catch validation errors and return raw data
                                let datasourceFieldsResult: any = null;
                                let workbookSemanticsResult: any = null;
                                let errors: any = {};

                                // Query 1: Get published data source fields using Zodios
                                try {
                                    const publishedQuery = getPublishedDataSourceQuery(datasourceLuid);
                                    datasourceFieldsResult = await restApi.metadataMethods.graphql(publishedQuery);
                                } catch (error) {
                                    errors.query1 = `Query 1 failed: ${error}`;
                                    // Even if validation fails, try to extract raw data from error
                                    if ((error as any)?.response?.data) {
                                        datasourceFieldsResult = (error as any).response.data;
                                    }
                                }

                                // Query 2: Get workbooks and their embedded data sources using Zodios
                                try {
                                    const workbookQuery = getWorkbookSemanticsQuery(datasourceLuid);
                                    workbookSemanticsResult = await restApi.metadataMethods.graphql(workbookQuery);
                                } catch (error) {
                                    errors.query2 = `Query 2 validation failed but data extracted from error`;

                                    // Extract the actual GraphQL response from the Zodios error
                                    const errorStr = error.toString();
                                    const receivedMatch = errorStr.match(/received:\s*(\{.*\})\s*$/s);

                                    if (receivedMatch) {
                                        try {
                                            // Parse the raw GraphQL response from the error message
                                            const rawResponse = JSON.parse(receivedMatch[1]);
                                            workbookSemanticsResult = rawResponse;
                                            errors.query2 += " - successfully extracted raw data from validation error";
                                        } catch (parseError) {
                                            errors.query2 += " - failed to parse raw data from error";
                                        }
                                    }

                                    // Also try the traditional approach
                                    if (!workbookSemanticsResult && (error as any)?.response?.data) {
                                        workbookSemanticsResult = (error as any).response.data;
                                    }
                                }

                                // Filter workbook semantics to only include unique fields
                                let filteredWorkbookSemantics = null;
                                let filteringDebug = {
                                    originalWorkbooksCount: 0,
                                    totalOriginalFields: 0,
                                    totalUniqueFields: 0,
                                    publishedFieldNames: [],
                                    filteredWorkbooks: []
                                };

                                if (datasourceFieldsResult?.data?.publishedDatasources?.[0]?.fields &&
                                    workbookSemanticsResult?.data?.publishedDatasources?.[0]?.downstreamWorkbooks) {

                                    // Create set of published field names for comparison
                                    const publishedFields = datasourceFieldsResult.data.publishedDatasources[0].fields;
                                    const publishedFieldNames = new Set(publishedFields.map(f => f.name));

                                    filteringDebug.publishedFieldNames = Array.from(publishedFieldNames);

                                    // Process each workbook
                                    const filteredWorkbooks = [];
                                    const originalWorkbooks = workbookSemanticsResult.data.publishedDatasources[0].downstreamWorkbooks;

                                    filteringDebug.originalWorkbooksCount = originalWorkbooks.length;

                                    for (const workbook of originalWorkbooks) {
                                        const filteredEmbeddedDatasources = [];

                                        for (const embeddedDs of workbook.embeddedDatasources || []) {
                                            const originalFields = embeddedDs.fields || [];
                                            filteringDebug.totalOriginalFields += originalFields.length;

                                            // Filter out fields that exist in published data source
                                            const uniqueFields = [];
                                            const matchedFields = [];

                                            for (const field of originalFields) {
                                                const isMatch = publishedFieldNames.has(field.name);
                                                if (isMatch) {
                                                    matchedFields.push({
                                                        workbookName: field.name,
                                                        workbookFQN: field.fullyQualifiedName,
                                                        matchedBy: 'name'
                                                    });
                                                } else {
                                                    uniqueFields.push(field);
                                                }
                                            }

                                            filteringDebug.totalUniqueFields += uniqueFields.length;

                                            // Add detailed field matching debug for this embedded data source
                                            if (!filteringDebug.fieldMatchingDetails) filteringDebug.fieldMatchingDetails = [];
                                            filteringDebug.fieldMatchingDetails.push({
                                                embeddedDatasourceName: embeddedDs.name,
                                                originalFieldCount: originalFields.length,
                                                uniqueFieldCount: uniqueFields.length,
                                                matchedFieldCount: matchedFields.length,
                                                sampleUniqueFields: uniqueFields.slice(0, 3).map(f => ({ name: f.name, fqn: f.fullyQualifiedName })),
                                                sampleMatchedFields: matchedFields.slice(0, 3),
                                                samplePublishedNames: Array.from(publishedFieldNames).slice(0, 3)
                                            });

                                            // Only include embedded data sources that have unique fields
                                            if (uniqueFields.length > 0) {
                                                filteredEmbeddedDatasources.push({
                                                    ...embeddedDs,
                                                    fields: uniqueFields
                                                });
                                            }
                                        }

                                        // Only include workbooks that have embedded data sources with unique fields
                                        if (filteredEmbeddedDatasources.length > 0) {
                                            const filteredWorkbook = {
                                                ...workbook,
                                                embeddedDatasources: filteredEmbeddedDatasources
                                            };
                                            filteredWorkbooks.push(filteredWorkbook);

                                            filteringDebug.filteredWorkbooks.push({
                                                name: workbook.name,
                                                originalEmbeddedDSCount: workbook.embeddedDatasources?.length || 0,
                                                filteredEmbeddedDSCount: filteredEmbeddedDatasources.length,
                                                totalUniqueFields: filteredEmbeddedDatasources.reduce((sum, ds) => sum + ds.fields.length, 0)
                                            });
                                        }
                                    }

                                    // Create the filtered result structure
                                    filteredWorkbookSemantics = {
                                        ...workbookSemanticsResult.data,
                                        publishedDatasources: [{
                                            ...workbookSemanticsResult.data.publishedDatasources[0],
                                            downstreamWorkbooks: filteredWorkbooks
                                        }]
                                    };
                                }

                                // Create debug information
                                const debugInfo = {
                                    query1: {
                                        name: "Published Data Source Fields",
                                        queryPreview: getPublishedDataSourceQuery(datasourceLuid).substring(0, 200) + "...",
                                        hasResult: !!datasourceFieldsResult,
                                        resultKeys: Object.keys(datasourceFieldsResult?.data?.publishedDatasources?.[0] || {}),
                                        hasFields: !!datasourceFieldsResult?.data?.publishedDatasources?.[0]?.fields,
                                        hasDownstreamWorkbooks: !!datasourceFieldsResult?.data?.publishedDatasources?.[0]?.downstreamWorkbooks,
                                        fieldsCount: datasourceFieldsResult?.data?.publishedDatasources?.[0]?.fields?.length || 0,
                                        error: errors.query1 || null,
                                    },
                                    query2: {
                                        name: "Workbook Semantics",
                                        queryPreview: getWorkbookSemanticsQuery(datasourceLuid).substring(0, 200) + "...",
                                        hasResult: !!workbookSemanticsResult,
                                        resultKeys: Object.keys(workbookSemanticsResult?.data?.publishedDatasources?.[0] || {}),
                                        hasDownstreamWorkbooks: !!workbookSemanticsResult?.data?.publishedDatasources?.[0]?.downstreamWorkbooks,
                                        workbooksCount: workbookSemanticsResult?.data?.publishedDatasources?.[0]?.downstreamWorkbooks?.length || 0,
                                        error: errors.query2 || null,
                                    },
                                    filtering: filteringDebug
                                };

                                // Return both results with debug info and only the filtered workbook semantics
                                return {
                                    data: {
                                        dataSemantics: {
                                            debugInfo,
                                            datasourceFields: datasourceFieldsResult?.data || null,
                                            workbookSemantics: filteredWorkbookSemantics,
                                        }
                                    }
                                };
                            },
                        }),
                    );
                },
            });
        },
    });

    return getSemanticsTool;
};
