import { z } from 'zod';

import { GraphQLResponse } from '../../sdks/tableau/apis/metadataApi.js';
import {
  FieldMetadata,
  Function,
  MetadataResponse,
} from '../../sdks/tableau/apis/vizqlDataServiceApi.js';

type Field = Partial<{
  name: string;
  dataType: FieldMetadata['dataType'];
  defaultAggregation: z.infer<typeof Function>;
  description: string;
  descriptionInherited: Array<{
    attribute: string;
    value: string | null;
  } | null>;
  dataCategory: string;
  role: string;
  defaultFormat: string;
  formula: string;
  isAutoGenerated: boolean;
  hasUserReference: boolean;
  binSize: number;
}>;

type CombinedFieldsResult = {
  fields: Array<Field>;
};

export function combineFields(
  readMetadataResult: MetadataResponse,
  listFieldsResult: GraphQLResponse,
): CombinedFieldsResult {
  // Create a response object that combines field data from
  // readMetadata (VizQL Data Service API) and listFields (GraphQL Metadata API) results
  // to optimize for LLM accuracy and reduce tokens in response.
  const combinedFields: CombinedFieldsResult = {
    fields: [],
  };

  if (!readMetadataResult.data) {
    if (listFieldsResult.data.publishedDatasources[0]?.fields.length) {
      // fallback to returning listFields results if we don't have any fields from readMetadata.
      for (const field of listFieldsResult.data.publishedDatasources[0].fields) {
        const toPush: Field = { name: field.name };
        if (field.dataType?.length) {
          toPush.dataType = field.dataType as Field['dataType'];
        }
        if (field.aggregation?.length) {
          toPush.defaultAggregation = field.aggregation as FieldMetadata['defaultAggregation'];
        }
        populateFieldWithAdditionalProperties(field as Field, toPush);
        combinedFields.fields.push(toPush);
      }
    }

    return combinedFields;
  }

  // Only include fields from readMetadata results in our response object since only those can be used in queries.
  for (const field of readMetadataResult.data) {
    // only keeping essential field properties.
    const toPush: Field = {
      name: field.fieldCaption,
      dataType: field.dataType,
    };

    if (field.defaultAggregation) {
      toPush.defaultAggregation = field.defaultAggregation;
    }

    combinedFields.fields.push(toPush);
  }

  if (!listFieldsResult.data.publishedDatasources[0]?.fields.length) {
    return combinedFields;
  }

  // Of the fields in our response object, populate them with additional properties we get from listFields results.
  for (const field of combinedFields.fields) {
    const matchingListField = listFieldsResult.data.publishedDatasources[0].fields.find(
      (f) => f.name === field.name,
    );
    if (matchingListField) {
      populateFieldWithAdditionalProperties(matchingListField as Field, field);
    }
  }

  return combinedFields;
}

function populateFieldWithAdditionalProperties(sourceField: Field, targetField: Field): void {
  if (sourceField.description?.length) {
    targetField.description = sourceField.description;
  }
  if (sourceField.descriptionInherited?.length) {
    targetField.descriptionInherited = sourceField.descriptionInherited;
  }
  if (sourceField.dataCategory) {
    targetField.dataCategory = sourceField.dataCategory;
  }
  if (sourceField.role) {
    targetField.role = sourceField.role;
  }
  if (sourceField.defaultFormat) {
    targetField.defaultFormat = sourceField.defaultFormat;
  }
  if (sourceField.formula?.length) {
    targetField.formula = sourceField.formula;
    // Possibly null or undefined, only populate if true or false.
    if (sourceField.isAutoGenerated != undefined) {
      targetField.isAutoGenerated = sourceField.isAutoGenerated;
    }
    // Possibly null or undefined, only populate if true or false.
    if (sourceField.hasUserReference != undefined) {
      targetField.hasUserReference = sourceField.hasUserReference;
    }
  }
  // Possibly null or undefined, only populate if defined.
  if (sourceField.binSize != undefined) {
    targetField.binSize = sourceField.binSize;
  }
}
