import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';

import { Server } from '../server.js';
import { getPublishedDataSourceQuery, getWorkbookSemanticsQuery, getGetSemanticsTool } from './getSemantics.js';

const mockMetadataResponses = vi.hoisted(() => ({
    publishedDataSource: {
        data: {
            publishedDatasources: [
                {
                    id: 'test-id',
                    luid: 'test-luid',
                    name: 'Test Datasource',
                    description: 'Test Description',
                    owner: {
                        name: 'Test Owner',
                    },
                    fields: [
                        {
                            name: 'Published Field 1',
                            isHidden: false,
                            description: 'Published field description',
                            descriptionInherited: [],
                            fullyQualifiedName: '[published_field_1]',
                            __typename: 'ColumnField',
                            dataCategory: 'NOMINAL',
                            role: 'DIMENSION',
                            dataType: 'STRING',
                        },
                        {
                            name: 'Published Field 2',
                            isHidden: false,
                            description: 'Another published field',
                            descriptionInherited: [],
                            fullyQualifiedName: '[published_field_2]',
                            __typename: 'ColumnField',
                            dataCategory: 'QUANTITATIVE',
                            role: 'MEASURE',
                            dataType: 'INTEGER',
                        },
                    ],
                },
            ],
        },
    },
    workbookSemantics: {
        data: {
            publishedDatasources: [
                {
                    downstreamWorkbooks: [
                        {
                            id: 'workbook-1-id',
                            luid: 'workbook-1-luid',
                            name: 'Top Workbook 1',
                            projectName: 'Test Project',
                            owner: {
                                name: 'Workbook Owner 1',
                            },
                            embeddedDatasources: [
                                {
                                    id: 'embedded-1',
                                    name: 'Embedded Datasource 1',
                                    fields: [
                                        // Published field that should be filtered out
                                        {
                                            name: 'Published Field 1',
                                            isHidden: false,
                                            description: 'Published field description',
                                            descriptionInherited: [],
                                            fullyQualifiedName: '[published_field_1]',
                                            __typename: 'ColumnField',
                                        },
                                        // Workbook-specific calculated field
                                        {
                                            name: 'Workbook Calc Field',
                                            isHidden: false,
                                            description: 'Workbook calculated field',
                                            descriptionInherited: [],
                                            fullyQualifiedName: '[workbook_calc_field]',
                                            __typename: 'CalculatedField',
                                            formula: 'SUM([published_field_2])',
                                            isAutoGenerated: false,
                                            hasUserReference: true,
                                        },
                                        // Workbook-specific group field
                                        {
                                            name: 'Workbook Group',
                                            isHidden: false,
                                            description: 'Workbook group field',
                                            descriptionInherited: [],
                                            fullyQualifiedName: '[workbook_group]',
                                            __typename: 'GroupField',
                                            hasOther: true,
                                        },
                                    ],
                                },
                            ],
                        },
                        {
                            id: 'workbook-2-id',
                            luid: 'workbook-2-luid',
                            name: 'Top Workbook 2',
                            projectName: 'Test Project 2',
                            owner: {
                                name: 'Workbook Owner 2',
                            },
                            embeddedDatasources: [
                                {
                                    id: 'embedded-2',
                                    name: 'Embedded Datasource 2',
                                    fields: [
                                        // Another workbook-specific field
                                        {
                                            name: 'Custom Field Alias',
                                            isHidden: false,
                                            description: 'Custom field with alias',
                                            descriptionInherited: [],
                                            fullyQualifiedName: '[custom_field_alias]',
                                            __typename: 'ColumnField',
                                            dataCategory: 'NOMINAL',
                                            role: 'DIMENSION',
                                            dataType: 'STRING',
                                        },
                                    ],
                                },
                            ],
                        },
                    ],
                },
            ],
        },
    },
    empty: {
        data: {
            publishedDatasources: [],
        },
    },
    noWorkbookSemantics: {
        data: {
            publishedDatasources: [
                {
                    id: 'test-id',
                    luid: 'test-luid',
                    name: 'Test Datasource',
                    description: 'Test Description',
                    owner: {
                        name: 'Test Owner',
                    },
                    fields: [
                        {
                            name: 'Published Field 1',
                            isHidden: false,
                            description: 'Published field description',
                            descriptionInherited: [],
                            fullyQualifiedName: '[published_field_1]',
                            __typename: 'ColumnField',
                        },
                    ],
                    downstreamWorkbooks: [
                        {
                            id: 'workbook-1-id',
                            luid: 'workbook-1-luid',
                            name: 'Workbook With No Unique Fields',
                            projectName: 'Test Project',
                            owner: {
                                name: 'Workbook Owner 1',
                            },
                            embeddedDatasources: [
                                {
                                    id: 'embedded-1',
                                    name: 'Embedded Datasource 1',
                                    fields: [
                                        // Only published field, no unique workbook fields
                                        {
                                            name: 'Published Field 1',
                                            isHidden: false,
                                            description: 'Published field description',
                                            descriptionInherited: [],
                                            fullyQualifiedName: '[published_field_1]',
                                            __typename: 'ColumnField',
                                        },
                                    ],
                                },
                            ],
                        },
                    ],
                },
            ],
        },
    },
}));

const mocks = vi.hoisted(() => ({
    mockGraphql: vi.fn(),
}));

vi.mock('../restApiInstance.js', () => ({
    useRestApi: vi.fn().mockImplementation(async ({ callback }) =>
        callback({
            metadataMethods: {
                graphql: mocks.mockGraphql,
            },
        }),
    ),
}));

describe('getSemanticsTool', () => {
    beforeEach(() => {
        vi.clearAllMocks();
    });

    it('should create a tool instance with correct properties', () => {
        const getSemanticsTool = getGetSemanticsTool(new Server());
        expect(getSemanticsTool.name).toBe('get-semantics');
        expect(getSemanticsTool.paramsSchema).toMatchObject({ datasourceLuid: expect.any(Object) });
    });

    it('should successfully fetch and return semantics with workbook fields', async () => {
        // Mock the dual query responses
        mocks.mockGraphql
            .mockResolvedValueOnce(mockMetadataResponses.publishedDataSource) // First call - published data source
            .mockResolvedValueOnce(mockMetadataResponses.workbookSemantics); // Second call - workbook semantics

        const result = await getToolResult();

        expect(result.isError).toBe(false);
        const responseData = JSON.parse(result.content[0].text as string);

        // Check that the published datasource fields are included
        expect(responseData.data.publishedDatasources[0].fields).toHaveLength(2);

        // Check that workbook semantics are properly extracted
        expect(responseData.data.publishedDatasources[0].workbookSemantics).toHaveLength(2);

        // First workbook should have 2 unique fields
        const workbook1Semantics = responseData.data.publishedDatasources[0].workbookSemantics[0];
        expect(workbook1Semantics.workbookName).toBe('Top Workbook 1');
        expect(workbook1Semantics.uniqueFields).toHaveLength(2);
        expect(workbook1Semantics.uniqueFields[0].name).toBe('Workbook Calc Field');
        expect(workbook1Semantics.uniqueFields[1].name).toBe('Workbook Group');

        // Second workbook should have 1 unique field
        const workbook2Semantics = responseData.data.publishedDatasources[0].workbookSemantics[1];
        expect(workbook2Semantics.workbookName).toBe('Top Workbook 2');
        expect(workbook2Semantics.uniqueFields).toHaveLength(1);
        expect(workbook2Semantics.uniqueFields[0].name).toBe('Custom Field Alias');

        // Verify both queries were called
        expect(mocks.mockGraphql).toHaveBeenCalledTimes(2);
        expect(mocks.mockGraphql).toHaveBeenNthCalledWith(1, getPublishedDataSourceQuery('test-luid'));
        expect(mocks.mockGraphql).toHaveBeenNthCalledWith(2, getWorkbookSemanticsQuery('test-luid'));
    });

    it('should handle workbooks with no unique semantics', async () => {
        mocks.mockGraphql
            .mockResolvedValueOnce(mockMetadataResponses.publishedDataSource)
            .mockResolvedValueOnce(mockMetadataResponses.noWorkbookSemantics);

        const result = await getToolResult();

        expect(result.isError).toBe(false);
        const responseData = JSON.parse(result.content[0].text as string);

        // Check that workbook semantics includes workbooks but with empty unique fields
        expect(responseData.data.publishedDatasources[0].workbookSemantics).toHaveLength(1);
        expect(responseData.data.publishedDatasources[0].workbookSemantics[0].uniqueFields).toHaveLength(0);

        expect(mocks.mockGraphql).toHaveBeenCalledTimes(2);
    });

    it('should successfully fetch and return empty list when no published datasources are found', async () => {
        mocks.mockGraphql.mockResolvedValue(mockMetadataResponses.empty);

        const result = await getToolResult();

        expect(result.isError).toBe(false);
        expect(JSON.parse(result.content[0].text as string)).toEqual(mockMetadataResponses.empty);
        expect(mocks.mockGraphql).toHaveBeenCalledWith(getPublishedDataSourceQuery('test-luid'));
    });

    it('should handle API errors gracefully', async () => {
        const errorMessage = 'API Error';
        mocks.mockGraphql.mockRejectedValue(new Error(errorMessage));

        const result = await getToolResult();
        expect(result.isError).toBe(true);
        expect(result.content[0].text).toBe('requestId: test-request-id, error: API Error');
    });
});

async function getToolResult(): Promise<CallToolResult> {
    const getSemanticsTool = getGetSemanticsTool(new Server());
    return await getSemanticsTool.callback(
        { datasourceLuid: 'test-luid' },
        {
            signal: new AbortController().signal,
            requestId: 'test-request-id',
            sendNotification: vi.fn(),
            sendRequest: vi.fn(),
        },
    );
}
