import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { readFileSync, unlinkSync } from 'fs';
import { Err, Ok } from 'ts-results-es';
import { z } from 'zod';

import { Server } from '../../server.js';
import { getLargeResultFilePath } from '../../server/getLargeResult.js';
import { getExceptionMessage } from '../../utils/getExceptionMessage.js';
import { Tool } from '../tool.js';

const paramsSchema = {
  fileResourceId: z.string(),
};

export const getLargeResultTool = (server: Server): Tool<typeof paramsSchema> => {
  const largeResultTool = new Tool({
    server,
    name: 'get-large-result',
    description:
      'This tool retrieves a large result that was previously generated by another tool. The result is stored on the server and can be accessed by providing the file resource ID.',
    paramsSchema,
    isResultSizeUnlimited: true,
    annotations: {
      title: 'Get Large Result',
      readOnlyHint: true,
      destructiveHint: true, // The result is deleted from the server after it is accessed.
      openWorldHint: false,
    },
    callback: async ({ fileResourceId }, { requestId, authInfo }): Promise<CallToolResult> => {
      return await largeResultTool.logAndExecute({
        requestId,
        authInfo,
        args: { fileResourceId },
        callback: async () => {
          const result = getLargeResultFilePath(fileResourceId);
          if (result.isErr()) {
            return Err(result.error.message);
          }

          try {
            const contents = readFileSync(result.value.fullFilePath);
            const text = contents.toString('utf8');
            unlinkSync(result.value.fullFilePath);
            return Ok(JSON.parse(text));
          } catch (error) {
            return Err(getExceptionMessage(error));
          }
        },
        constrainSuccessResult: (result) => ({ type: 'success', result }),
        getErrorText: (error) => error,
      });
    },
  });

  return largeResultTool;
};
